/**
 * src/routes/auth.ts
 *
 * Authentication routes: /auth/register and /auth/login
 *
 * REGISTER FLOW:
 * 1. Client sends: email, password, encrypted_master_key, master_key_iv, salt
 * 2. Server hashes the password (never stores plaintext)
 * 3. Server generates a PBKDF2 salt (for client-side key derivation)
 *    Wait — actually the CLIENT generates the salt and sends it.
 *    This is important: the server can't derive your key without your password.
 * 4. Server stores: email, password_hash, encrypted_master_key, master_key_iv, salt
 * 5. Server returns: JWT token + user info
 *
 * LOGIN FLOW:
 * 1. Client sends: email, password
 * 2. Server looks up user by email
 * 3. Server verifies password against stored hash
 * 4. If correct: return JWT token + encrypted_master_key + salt
 * 5. Client uses salt + password to re-derive wrapping key
 * 6. Client decrypts master key locally
 *
 * NOTE: We use Zod for input validation.
 * Zod checks that inputs are the right type and format before we process them.
 * This prevents bugs and injection attacks.
 */

import { FastifyInstance } from 'fastify';
import { z } from 'zod';
import sql from '../db/client';
import { hashPassword, verifyPassword, generateSalt } from '../crypto/serverCrypto';
import { authenticate } from '../middleware/auth';

// ─────────────────────────────────────────────────────────────────────────────
// INPUT VALIDATION SCHEMAS (Zod)
// ─────────────────────────────────────────────────────────────────────────────

// Schema for registration request body
const RegisterSchema = z.object({
  email: z.string().email('Must be a valid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),

  // These come from the client's crypto operations (done BEFORE hitting this endpoint)
  encrypted_master_key: z.string().min(1, 'encrypted_master_key is required'),
  master_key_iv: z.string().min(1, 'master_key_iv is required'),
  salt: z.string().min(1, 'salt is required'), // PBKDF2 salt, generated by client
});

// Schema for login request body
const LoginSchema = z.object({
  email: z.string().email('Must be a valid email address'),
  password: z.string().min(1, 'Password is required'),
});

// TypeScript types inferred from schemas
type RegisterBody = z.infer<typeof RegisterSchema>;
type LoginBody = z.infer<typeof LoginSchema>;

// ─────────────────────────────────────────────────────────────────────────────
// ROUTE PLUGIN
// ─────────────────────────────────────────────────────────────────────────────

export async function authRoutes(fastify: FastifyInstance) {

  // ── POST /auth/register ──────────────────────────────────────────────────
  fastify.post<{ Body: RegisterBody }>('/auth/register', async (request, reply) => {
    // 1. Validate input
    const parseResult = RegisterSchema.safeParse(request.body);
    if (!parseResult.success) {
      return reply.status(400).send({
        error: 'Validation failed',
        details: parseResult.error.flatten().fieldErrors,
      });
    }

    const { email, password, encrypted_master_key, master_key_iv, salt } = parseResult.data;

    // 2. Check if email already exists
    const existingUser = await sql`
      SELECT id FROM users WHERE email = ${email} LIMIT 1
    `;

    if (existingUser.length > 0) {
      return reply.status(409).send({
        error: 'Email already registered',
        message: 'An account with this email already exists. Please log in instead.',
      });
    }

    // 3. Hash the password
    // We store the hash, never the plaintext password
    const passwordHash = await hashPassword(password);

    // 4. Insert user into database
    const [newUser] = await sql`
      INSERT INTO users (
        email,
        password_hash,
        encrypted_master_key,
        master_key_iv,
        salt
      ) VALUES (
        ${email},
        ${passwordHash},
        ${encrypted_master_key},
        ${master_key_iv},
        ${salt}
      )
      RETURNING id, email, created_at
    `;

    // 5. Generate JWT token
    // The token payload contains the user's ID and email
    // The server signs it with JWT_SECRET — tampering breaks the signature
    const token = fastify.jwt.sign(
      {
        userId: newUser.id,
        email: newUser.email,
      },
      { expiresIn: process.env.JWT_EXPIRY || '7d' }
    );

    // 6. Return success
    return reply.status(201).send({
      message: 'Account created successfully',
      token,
      user: {
        id: newUser.id,
        email: newUser.email,
        created_at: newUser.created_at,
      },
    });
  });


  // ── POST /auth/login ─────────────────────────────────────────────────────
  fastify.post<{ Body: LoginBody }>('/auth/login', async (request, reply) => {
    // 1. Validate input
    const parseResult = LoginSchema.safeParse(request.body);
    if (!parseResult.success) {
      return reply.status(400).send({
        error: 'Validation failed',
        details: parseResult.error.flatten().fieldErrors,
      });
    }

    const { email, password } = parseResult.data;

    // 2. Look up user by email
    const [user] = await sql`
      SELECT id, email, password_hash, encrypted_master_key, master_key_iv, salt, created_at
      FROM users
      WHERE email = ${email}
      LIMIT 1
    `;

    // Use the same generic error for "wrong email" and "wrong password"
    // This prevents attackers from knowing which one is wrong (user enumeration)
    const invalidCredentialsError = {
      error: 'Invalid credentials',
      message: 'Email or password is incorrect.',
    };

    if (!user) {
      // Add artificial delay to match password hashing time
      // This prevents timing attacks (attacker can't tell if user exists by response time)
      await new Promise(r => setTimeout(r, 100));
      return reply.status(401).send(invalidCredentialsError);
    }

    // 3. Verify password
    const passwordValid = await verifyPassword(password, user.password_hash);
    if (!passwordValid) {
      return reply.status(401).send(invalidCredentialsError);
    }

    // 4. Generate JWT token
    const token = fastify.jwt.sign(
      {
        userId: user.id,
        email: user.email,
      },
      { expiresIn: process.env.JWT_EXPIRY || '7d' }
    );

    // 5. Return token + encrypted master key data
    // The client needs encrypted_master_key, master_key_iv, and salt
    // to re-derive the wrapping key and decrypt the master key locally
    return reply.status(200).send({
      message: 'Login successful',
      token,
      user: {
        id: user.id,
        email: user.email,
        created_at: user.created_at,
      },
      // These are returned so the client can decrypt the master key
      // Server cannot use these without knowing the password
      crypto: {
        encrypted_master_key: user.encrypted_master_key,
        master_key_iv: user.master_key_iv,
        salt: user.salt,
      },
    });
  });


  // ── GET /auth/me ─────────────────────────────────────────────────────────
  // Returns the current user's info. Useful for the extension to verify
  // its token is still valid after a browser restart.
  fastify.get('/auth/me', {
    preHandler: [authenticate],
  }, async (request, reply) => {
    const { userId } = request.user;

    const [user] = await sql`
      SELECT id, email, encrypted_master_key, master_key_iv, salt, created_at
      FROM users
      WHERE id = ${userId}
      LIMIT 1
    `;

    if (!user) {
      return reply.status(404).send({ error: 'User not found' });
    }

    return reply.send({
      user: {
        id: user.id,
        email: user.email,
        created_at: user.created_at,
      },
      crypto: {
        encrypted_master_key: user.encrypted_master_key,
        master_key_iv: user.master_key_iv,
        salt: user.salt,
      },
    });
  });

}